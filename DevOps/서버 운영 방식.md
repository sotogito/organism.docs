# 1. 물리 서버 (Physical Server)
- 실물 장비
- 하나의 서버에 OS와 애플리케이션을 직접 설피해서 사용
- 문제점
	- 서버 자원을 하나의 서비스만 차지 -> 낭비 심함
	- 새로운 서비스 설치하려면 또 다른 서버를 사야 함
	- 확장이 느리고 비용 큼

# 1. 가상 서버 (Virtual Machine, VM)
- 물리 서버 위에 하이퍼바이저(Hypervisor) 설치 - VMware, KVM, Hyper-V
- 하나의 물리 서버르 여러개의 가상 서버VM로 쪼개서 사용
- 각 VM은 자체 OS와 애플리케이션을 가짐
	- Spring Boot는 VM A(포트 8080)
    - MySQL은 VM B(포트 3306)
    - Redis는 VM C(포트 6379)
    - OS 자체가 다르니까, **같은 포트 번호를 써도 전혀 충돌 안 함**
- 장점
	- 자원 효율이 높음 - 한 물리 서버에서 여러 서비스 가능
	- 서버 확장이 유연해짐
- 문제점
	- VM마다 OS 까지 포함 - 무겁고 시작이 느림
	- 서버 자원을 많이 차지

# 3. 컨테이너 (Container, Docker)
- VM 보다 라이트한 개념
- OS 커널을 공유하면서, 애플리케이션 실행 환경만 분리
- 이미지로부터 빠르게 실행 가능
- NameSpace : 프로세스가 자기만 쓰는 것처럼 격리
- cgroups : CPU, 메모리, 디스크 I/O같은 자원 사용량을 제한
- 장점
	- 시작 속도 빠름
	- 자원 효율 최고
	- 이식성 높음- 어디서나 실행 가능
- 문제점
	- 컨테이션 개수가 많아지면 관리가 힘듦

# 4. 쿠버네티스 (Kubernetes)
- 컨테이너를 수백, 수천 개 규모로 자동 관리하는 플랫폼
- Pod, Depolyment, Service 같은 리소스로 컨테이너를 묶어 관리
- 자동 배포, 스케일링, 장애 복구 지원
- 컨테이너 오케스트레이션 도구

---
1. 온프레미스 ON-PREMISE
	- 기존의 서버 운영 방식
	- 모든 하드웨어, 소프트웨어, 네트워크를다 갖추고 운영
2. 클라우드 - CLOUD
	- 시스템 운영에 필요한 장비를 갖추지 않고 네트워크 상에서 제공되는 서비스를 임대하여 운영
	- IaaS -> PaaS -> SaaS
		- IaaS : 서버, 하드웨어, 네트쿼크, 스토리지 등을 서비스로
		- Paas : 애플리케이션 구축, 실행하는데 필요한 플팻폼을 제공
		- SaaS : 소프트웨어 설치 없이 이용할 수 있는 애플리케이션


외부(워크밴치)에서 db접근을 하기 위해서
hostname : IP주소 / port3306

MobaXterm -> /etc/mysql/mysql.conf.d/으로 이동하여 mysqld.cnf 파일을 수정한다. -> bind-address		= 0.0.0.0


배포하고싶은 파일 인텔리제이로 열어서 gradle -> build -> clear -> build

- build.gradle
```
tasks.named('jar'){  
    enabled = false  
}
```

build -> libs -> springdatajpa-0.0.1-SNAPSHOT.jar 파일로 실행 파일 생성

빌드 파일을 서버로 이동시켜 실행 -> 외부에ㅓㅅ 서버 띄우는 법
서버에서 실행하기 위해서는자바 명령어로 실행시켜야하기 때문에 자바를 설치해야한다.
`apt-get install openjdk-17-jdk`

- 자바 설치경로 확인
```
root@sooyeon-ncpserver:~# update-alternatives --list java
/usr/lib/jvm/java-17-openjdk-amd64/bin/java
```

#### 자바 환경변수 설정
전역에서 사용하기 위해서
/root/ -> .profile -> 아래 코드 추가 -> 적용 시키기 위해 명령어`source ~/.profile`
```
# JAVA_HOME
export JAVA_HOME=/usr/lib/jvm/java-17-openjdk-amd64
export PATH=$JAVA_HOME/bin:$PATH
```
#### jar 파일 실행
1. jar 파일을 /root/에 드래그한다
2. `java -jar springdatajpa-0.0.1-SNAPSHOT.jar` 명령
```

root@sooyeon-ncpserver:~# java -jar springdatajpa-0.0.1-SNAPSHOT.jar

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/

 :: Spring Boot ::                (v3.4.6)

2025-06-16T12:33:35.743+09:00  INFO 25988 --- [06_spring-data-jpa] [           main] com.sotogito.springdatajpa.Application   : Starting Application v0.0.1-SNAPSHOT using Java 17.0.15 with PID 25988 (/root/springdatajpa-0.0.1-SNAPSHOT.jar started by root in /root)
2025-06-16T12:33:35.753+09:00  INFO 25988 --- [06_spring-data-jpa] [           main] com.sotogito.springdatajpa.Application   : No active profile set, falling back to 1 default profile: "default"
2025-06-16T12:33:37.072+09:00  INFO 25988 --- [06_spring-data-jpa] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode.

```

공인IP로 접속하면 실행됨


---
#### 1. 자원을 나누는 이유는?
1. 비용 절감
	- 서버는 CPU, 메모리 자원이 항상 100% 쓰지지 않아 남는 자원이 많음
	- 자원을 나누면 여러 애플리케이션을 같은 서버를 공유해서, 남는 자원을 최소화하고 비용을 줄일 수 있음
2. 독립성 & 안정성
	- 하나의 서버에 여러 애픙이케이션을 같이 깔면 충돌이 커지지만, VM이나 컨테이너로 분리하면 서로 독립된 공간에서 실행되어 안정성이 높아짐
	- 한 애플리케이션이 죽어도 다른 애플리케이션에 영향이 최소화됨
3. 빠른 확장
	- 트래픽이 몰리면 특정 서비스만 자원을 더 늘려줘야하는데, 서버 전체를 늘리는 것은 비효율적.
	- 자원을 나눠두면, 필요한 서비스만 빠르게 확장 가능 -> 서비스별 맞춤 확장이 가능해짐
4. 이식성
	- 컨테이너 단위로 나누면, 환경에 상관없이 똑같이 실행
5. 관리 자동화
	- 쿠버네티스 같은 오케스트레이션 도구는 자원이 나눠져 있을 때 자동 배치, 자동 복구, 자동 확장을 해줄 수 있음

#### 2. VM과 컨테이너의 자원 분리 차이는?
- VM = 하드웨어 레벨에서 나눔
	- 하이퍼나이저라는 가상화 소프트퉤어가 물리 서버 위에 깔림
	- 하이퍼나이저는 CPU, 메모리, 디스크롤 OS 단위로 쪼개서 VM 에게 할당
	- VM은 자기 전용OS를 가지고 있고, 그 위에 애플리케이션을 설치
- 컨테이너 = OS 레벨에서 나눔
	- 호스트 OS 커널을 공유, 하드우에어를 직접 나눠쓰지 않음
	- OS 레벨에서 프로세스 격리 기술을 이용해 컨테이너 별로 나눠 실행
	- 컨테이너 안에는 OS 전체가 아니라, 앱 실행에 필요한 라이브러리와 실행 환경만 들어있음
컨테이너도 CPU, 메모리 같은 자원을 할당받아 쓰지만, 하드웨어를 쪼개쓴다는 VM 개념이 아님
- VM : 하드웨어 쪼갬
- 컨테이너 : 하드웨어 공유