 - <mark style="background: #FFF3A3A6;">메서드명 짓는 데 최선을 다하라</mark>
	 - 메서드명을 짓기 어렵다면 역할별로 기능분리를 하지 못한 것이다.
- <mark style="background: #FFF3A3A6;">클래스명을 짓는 데 최선을 다하라</mark>
	 - 클래스명을 짓기 어렵다면 추상화 계층을 잘못 나눈 것이다.
 - <mark style="background: #FFF3A3A6;">커밋메시지를 남기는 데 최선을 다하라</mark>
	 - 커밋메시지를 남기기 어렵다면 기능단위로 구현하지 않았으며 의식적으로 코딩하지 않은 것이다.
---
- finder 같은 기능을 통해 객체의 종류를 아예 변경하고 싶다면 return을 사용하라
- 문자, 숫자등을 parser할때는 trim()을 사용하라
- 기능을 각주로 설명하지 말고 메서드로 설명하라
- 가장 기본적으로 처리해야될 로직부터 작성하라 ex) ""입력되면 0을 출력
- 출력은 하나씩 하지 말고 한번에 하라
- 서비스에서 직접 출력을 할 수 없지만, 출력에 필요한 데이터는 반환할 수 있다.
	자동차 경주에서 중간 결과를 출력할 수는 없지만 중간 결과를 출력형태로 계속 저장한 데이터를 반환할 수는 있다.
- 주요 로직에 필요한 객체(Repo,Helper...)가 2개 이상이면 서비스 생성을 고려해봐라
- 재사용 가능성이 높은 데이터의 경우 객체의 필드로 관리하라.
- 사용자의 입력에 따라 바뀌는 데이터는 객체로 컨트롤러에서 생성 후 서비스 인수로 전달하라 ex)Member
- 서비스 생성자에는 고정적인 의존성(calculator)만 주입하라.
- 객체는 한가지의 역할을 수행하되, 필요한 상태와 행동은 여러개여도 괜찮다. - 단일 책임의 원칙
- 절대적인 짝이 되는 데이터는 객체 생성을 고려하라 ex)x,y 좌표
	- Result에 가깝다면 Map의 형태도 괜찮다.
- 하나의 데이터에 동기화된 상태 업데이트가 필요하다면 하나의 객체로 묶어라
- 출력에 다른 클래에서 필요한 데이터는 컨트롤러에서 객체를 만들어 의존성을 주입하라
- Enum 데이터를 담은 컬렉터는 Enum이 생성해서 반환하도록 하라
- 일단 final로 선언한 추후 업데이트해야 하면 리스트 자체를 매개변수로 넘겨라
- 특정 리스트를 반환할때는 그 데이터를 가지고 있는 클래스에서 반환하도록하라
- 컬렉터를 전달할 때 불변을 고려하라
- 간단한 싱글톤은 Enum싱글톤을 활용하라
- Y,N같은 특정 입력값 처리는 String이 아닌 Enum 상수로 넘겨라 - 대답이 추가되면 Enum에서 통합 처리
- 테스트를 위해 메서드의 인수는 객체가 아닌 데이터로 넘겨라
- **중첩된 while문**에서 바깥쪽 while문을 완전히 종료하려면, 내부의 while문을 먼저 빠져나와야 한다.
- 반복,종료 조건이 복잡하다면 While(true)를 사용하고 중첩되지 않는 if문을 사용하라
	- 가장 상위 종료 조건을 가장 상단 조건문에 배치하라
- 향상된 for문을 돌리면서 요소를 remove 삭제하지 마라
	- removeIf를 사용하여 안전하게 삭제하라
- 바로 boolean 결과를 반환하는게 아니면 if문으로 반환하라
	- 조건에 맞는 요소가 있는지 확인하는 것과
	- 조건에 대한 t/f를 넘기는 것은 다른 로직이다.
- 복잡하지만 서로 묶여 많이 사용되는 데이터라면 DTO를 생성하라 
	- 단순히 객체를 전달하기 위해서는 record를 생성하라
- 추후 하나씩 추가해야할 데이터가 아니면 생성자를 통해 생성하라
	- 나중에 추가되는 필드가 있으면 Build패턴을 고려하라
- 빈 값을 split하여 List<String,>을 만들면 사이즈가 1이다
	- 빈 값 그대로 처리하고 싶으면 split 전에 처리한다.
- 객체는 매개변수로 넣어준다면 새로 참조하지 않는 이상 밖의 객체와 동기화되지만, int,boolean같은 기본 자료형은 안된다.
- 객체를 equal 오버라이딩 했으면 반드시 비교할때 .equal를 사용하라, \==를 사용하지 말하라.
- map은 key로 조회하기는 쉽지만, value로 조회와, 인덱스로 특정 값을 가져올 수 없다는 단점이 있다.
	- Map을 인덱스로 순회하고 싶다면 `List<Map.Entry>`를 만들어라
- 데이터의 존재 확인 후 가져와 로직을 처리하기 위해서는 Optional을 사용하라
- "One-To-Many" 관계보다 "Many-To-One" 관계를 지향하라 - 여러 학생이 하나의 학교를 다닌다
- 2중 Map의 사용도 고려해봐라 - 메뉴 추천
- EnumMap을 null로 초기화를 하는 것과 new EnumMap<>()으로 초기화 하는 것은 다르다.
- 객체에 추가하는 요소, 삭제하는 요소는 서비스가 아닌 객체 내부에서 판단하도록 하라
	- 예를들어 메뉴추천에서 코치들의 메뉴를 추가할때, 코치들이 음식에 추가하지 못하는 경우는 2가지이다.
	1. 못먹는 메뉴일 때
	2. 이미 들어가있는 메뉴일때
	서비스에서 메뉴를 랜덤 생성하는거까지는 구현하고 이를 추가할때 위의 1,2두가지 경우의 조건문을 가지는 것은 코치 객체 내가 되어야한다. 
	서비스에서는 그냥 add를 해주고<mark style="background: #ABF7F7A6;"> 코치에서 검증+추가 로직</mark>을 갖는 메서드로 add해주면 된다.
	만약 들어가지 않았을 경우 다시 메뉴를 만들어야한다면 boolean으로 확인해주면 된다,
	```java
	public class Coach {
	    private List<String> recommendedMenus;
	    private List<String> notEatableMenus;

		    // 메뉴 추가 + 검증 메서드
	    public boolean addMenu(String menuName) {
	        if (canRecommendMenu(menuName)) {
	            recommendedMenus.add(menuName);
	            return true;
	        }
	        return false;
	    }

	```
	그럼 객체가 좀 더 주체적으로 행동할 수 잇다.
- Reader에서 파일을 읽어오는 것은 프로그램이 시작할때 미리 생성하지 않고 데이터가 필요할 때 읽어와도 된다.
- 변수명을 지을 때 자료형 타입을 포함하는 것을 지양하라(menuList는 괜찮지만 userString, menuDto같은 명은 리팩토링에 취약하다)
- 요구되는데이터.equals(입력값); 으로 작성하라. 순서를 바꾸면 NullPointExcepption이 던져질 가능성이 있다."예".equals(sc.nextLine())
